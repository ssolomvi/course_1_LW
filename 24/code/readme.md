# Построение дерева выражений.
## Общий алгоритм:
   Ищется главный оператор, относительно которого выражение разбивается на две
   части, рекурсивно вычисляемые этим же алгоритмом, и образующие левое и правое
   поддеревья.
   Главный оператор помещается в вершину дерева, а то, что по бокам -- в поддеревья.

## Поиск главного (образующего вершину) оператора:
   Ищется последний оператор с наименьшим приоритетом. Если это степень, то из-за
   её правоассоциативности идём влево до самой первой степени в цепочке связанных
   степеней (вторая ^ в 1^2 + 2^3^4), которую и считаем главным оператором.

Пример:
   \[2, +, 2, \*, 2]
   Последний оператор с наименьшим приоритетом -- '+'. Заносим его в вершину и
   разбиваем выражение относительно него на две части: \[2] и \[2, \*, 2], каждое из
   которых вычисляем таким же образом. В первом first == last (0 == 0, это индекс
   в массиве), поэтому это - число.
   Получается дерево
                            +|-- 2
            +|-- \*
                    -|-- 2
   +|-- +
            -|-- 2


## Задание варианта 4: упростить, выполнив деление (4\*a/2 -> 2/a, etc).
Приводим дерево к упрощённому виду: удаляем лишние минусы
(функция transform.c: find_minus_operator) и раскладываем произведение
делителей, если оно есть (функция transform.c: check_if_mult).
    
Находим узел дерева, содержащий операнд деления. Рекурсивно выполняем
поиск делимого снизу вверх (функция transform.c: find_div), и, если оно 
найдено, трансформируем дерево (transform.c: div_transform): удаляем 
соответсвующий операнд деления и делитель, производим деление.
При этом обходе первая замена оказывается самой левой и самой нижней.
